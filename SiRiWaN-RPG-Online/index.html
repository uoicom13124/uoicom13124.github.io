<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Game</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #1a1a2e;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: monospace;
  }

  #game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
  }

  #map-container {
    position: absolute;
    top: 0;
    left: 0;
    transition: transform 0.15s linear;
  }

  .tile {
    position: absolute;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  }

  .tile img {
    width: 100%;
    height: 100%;
    display: block;
    image-rendering: pixelated;
  }

  /* Fallback tile colors when images are missing */
  .tile-grass1 { background: #4a7c3f; }
  .tile-grass2 { background: #5a8c4f; }
  .tile-water { background: #2255aa; }
  .tile-sand { background: #c8a85a; }
  .tile-stone { background: #888888; }
  .tile-tree { background: #2d5a1b; }
  .tile-wall { background: #555566; }
  .tile-path { background: #b8a070; }

  /* Character */
  #character {
    position: absolute;
    width: 40px;
    height: 40px;
    z-index: 100;
    pointer-events: none;
    transform: translate(-50%, -50%);
    transition: left 0.15s linear, top 0.15s linear;
  }

  #character-sprite {
    width: 100%;
    height: 100%;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* CSS character sprite - pixel art style */
  .char-body {
    position: absolute;
    width: 22px;
    height: 32px;
  }

  .char-head {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 14px;
    height: 14px;
    background: #f4c48c;
    border-radius: 2px;
    border: 2px solid #c8855a;
  }

  .char-eyes {
    position: absolute;
    top: 4px;
    left: 50%;
    transform: translateX(-50%);
    width: 8px;
    height: 3px;
    display: flex;
    gap: 4px;
  }

  .char-eye {
    width: 2px;
    height: 3px;
    background: #333;
    border-radius: 1px;
  }

  .char-torso {
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    width: 14px;
    height: 12px;
    background: #3355cc;
    border: 2px solid #2244aa;
    border-radius: 1px;
  }

  .char-legs {
    position: absolute;
    top: 22px;
    left: 50%;
    transform: translateX(-50%);
    width: 12px;
    height: 10px;
    display: flex;
    gap: 2px;
  }

  .char-leg {
    flex: 1;
    background: #222288;
    border-radius: 1px;
    transform-origin: top center;
    border: 1px solid #111166;
  }

  /* Walking animations */
  @keyframes walk-leg-left {
    0%, 100% { transform: rotate(15deg); }
    50% { transform: rotate(-15deg); }
  }

  @keyframes walk-leg-right {
    0%, 100% { transform: rotate(-15deg); }
    50% { transform: rotate(15deg); }
  }

  @keyframes bob {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-2px); }
  }

  #character.walking .char-leg:first-child {
    animation: walk-leg-left 0.3s infinite;
  }

  #character.walking .char-leg:last-child {
    animation: walk-leg-right 0.3s infinite;
  }

  #character.walking .char-body {
    animation: bob 0.3s infinite;
  }

  /* Direction facing */
  #character.facing-left .char-head { border-color: #c8855a; }
  #character.facing-right .char-head { border-color: #c8855a; }

  /* Shadow under character */
  .char-shadow {
    position: absolute;
    bottom: -2px;
    left: 50%;
    transform: translateX(-50%);
    width: 18px;
    height: 6px;
    background: rgba(0,0,0,0.3);
    border-radius: 50%;
  }

  /* Mobile controls */
  #mobile-controls {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 1000;
    display: none;
    user-select: none;
    -webkit-user-select: none;
  }

  .dpad {
    display: grid;
    grid-template-columns: 44px 44px 44px;
    grid-template-rows: 44px 44px 44px;
    gap: 4px;
  }

  .dpad-btn {
    background: rgba(255,255,255,0.15);
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 8px;
    color: white;
    font-size: 18px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.1s, transform 0.1s;
    -webkit-tap-highlight-color: transparent;
    backdrop-filter: blur(4px);
  }

  .dpad-btn:active,
  .dpad-btn.pressed {
    background: rgba(255,255,255,0.35);
    transform: scale(0.92);
  }

  .dpad-center { background: transparent; border-color: transparent; pointer-events: none; }

  /* Loading screen */
  #loading {
    position: fixed;
    inset: 0;
    background: #1a1a2e;
    z-index: 9999;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
  }

  .loading-spinner {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(255,255,255,0.1);
    border-top-color: #5af;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .loading-text {
    color: rgba(255,255,255,0.6);
    font-size: 13px;
    letter-spacing: 2px;
  }

  /* Error */
  #error-screen {
    position: fixed;
    inset: 0;
    background: #1a1a2e;
    z-index: 9998;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
    color: #ff6666;
    font-size: 14px;
  }

  /* Tile fallback pattern for missing images */
  .tile-fallback {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 8px;
    font-weight: bold;
    color: rgba(0,0,0,0.3);
    letter-spacing: -1px;
  }

  @media (max-width: 768px), (pointer: coarse) {
    #mobile-controls { display: flex; }
  }
</style>
</head>
<body>

<div id="loading">
  <div class="loading-spinner"></div>
  <div class="loading-text">LOADING MAP...</div>
</div>

<div id="error-screen">
  <div id="error-msg"></div>
</div>

<div id="game-container">
  <div id="map-container"></div>
  <div id="character">
    <div class="char-shadow"></div>
    <div class="char-body">
      <div class="char-head">
        <div class="char-eyes">
          <div class="char-eye"></div>
          <div class="char-eye"></div>
        </div>
      </div>
      <div class="char-torso"></div>
      <div class="char-legs">
        <div class="char-leg"></div>
        <div class="char-leg"></div>
      </div>
    </div>
  </div>
</div>

<div id="mobile-controls">
  <div class="dpad">
    <div></div>
    <button class="dpad-btn" id="btn-up">▲</button>
    <div></div>
    <button class="dpad-btn" id="btn-left">◀</button>
    <div class="dpad-center"></div>
    <button class="dpad-btn" id="btn-right">▶</button>
    <div></div>
    <button class="dpad-btn" id="btn-down">▼</button>
    <div></div>
  </div>
</div>

<script>
// ==================== TILE DEFINITIONS ====================
// Define tile properties: walkable, image path, fallback color, display name
const TILE_DEFS = {
  grass1:  { walkable: true,  img: 'img/map/grass1.png',  color: '#5a8c40', label: 'G1' },
  grass2:  { walkable: true,  img: 'img/map/grass2.png',  color: '#4a7c35', label: 'G2' },
};

// Auto-register unknown tile types as walkable with a generated color
function getTileDef(name) {
  if (TILE_DEFS[name]) return TILE_DEFS[name];
  // Auto-generate for unknown tiles
  const hash = [...name].reduce((a, c) => a + c.charCodeAt(0), 0);
  const hue = (hash * 47) % 360;
  TILE_DEFS[name] = {
    walkable: true,
    img: `img/map/${name}.png`,
    color: `hsl(${hue},50%,40%)`,
    label: name.substring(0, 2).toUpperCase()
  };
  return TILE_DEFS[name];
}

// ==================== MAP PARSER ====================
function parseMap(text) {
  const lines = text.trim().split('\n');
  const grid = [];
  for (const line of lines) {
    const row = [];
    // Match all [tilename] tokens
    const tokens = [...line.matchAll(/\[([a-zA-Z0-9_]+)\]/g)];
    for (const tok of tokens) {
      row.push(tok[1].toLowerCase());
    }
    if (row.length > 0) grid.push(row);
  }
  return grid;
}

// ==================== GAME STATE ====================
const TILE_SIZE = 48;
let mapGrid = [];
let mapCols = 0;
let mapRows = 0;

// Player position in tile coords (float for smooth movement)
let player = { x: 1, y: 1, facing: 'down', moving: false };
let targetX = 1, targetY = 1;
let moveProgress = 0;
let moveSpeed = 6; // tiles per second

let keysDown = {};
let mobileDir = null;
let lastTime = 0;
let walking = false;

const mapContainer = document.getElementById('map-container');
const character = document.getElementById('character');

// ==================== BUILD MAP ====================
// Cache for image load status
const imgCache = {};

function createTileEl(tileName, col, row) {
  const def = getTileDef(tileName);
  const el = document.createElement('div');
  el.className = `tile tile-${tileName}`;
  el.style.width = TILE_SIZE + 'px';
  el.style.height = TILE_SIZE + 'px';
  el.style.left = (col * TILE_SIZE) + 'px';
  el.style.top = (row * TILE_SIZE) + 'px';
  el.style.background = def.color;

  const img = document.createElement('img');
  img.src = def.img;
  img.alt = '';
  img.style.width = '100%';
  img.style.height = '100%';
  img.style.display = 'block';
  img.draggable = false;

  img.onerror = () => {
    img.remove();
    // Show label fallback
    el.classList.add('tile-fallback');
    el.textContent = def.label;
    el.style.fontSize = '8px';
    el.style.color = 'rgba(0,0,0,0.25)';
    el.style.fontWeight = 'bold';
    el.style.display = 'flex';
    el.style.alignItems = 'center';
    el.style.justifyContent = 'center';
  };

  el.appendChild(img);
  return el;
}

function buildMap(grid) {
  mapGrid = grid;
  mapRows = grid.length;
  mapCols = grid[0]?.length || 0;

  mapContainer.innerHTML = '';
  mapContainer.style.width = (mapCols * TILE_SIZE) + 'px';
  mapContainer.style.height = (mapRows * TILE_SIZE) + 'px';

  const frag = document.createDocumentFragment();
  for (let r = 0; r < mapRows; r++) {
    for (let c = 0; c < mapCols; c++) {
      const name = grid[r][c] || 'grass1';
      frag.appendChild(createTileEl(name, c, r));
    }
  }
  mapContainer.appendChild(frag);
}

// ==================== CAMERA / SCROLL ====================
function updateCamera() {
  const vw = window.innerWidth;
  const vh = window.innerHeight;

  // Center camera on player pixel position
  const px = (player.x + 0.5) * TILE_SIZE;
  const py = (player.y + 0.5) * TILE_SIZE;

  let ox = vw / 2 - px;
  let oy = vh / 2 - py;

  // Clamp so we don't show beyond map edges
  const mapW = mapCols * TILE_SIZE;
  const mapH = mapRows * TILE_SIZE;
  ox = Math.min(0, Math.max(vw - mapW, ox));
  oy = Math.min(0, Math.max(vh - mapH, oy));

  mapContainer.style.transform = `translate(${ox}px, ${oy}px)`;

  // Character stays fixed at center of screen
  character.style.left = (vw / 2) + 'px';
  character.style.top = (vh / 2) + 'px';
}

// ==================== MOVEMENT ====================
function isWalkable(col, row) {
  if (col < 0 || row < 0 || col >= mapCols || row >= mapRows) return false;
  const name = mapGrid[row][col];
  return getTileDef(name).walkable;
}

function tryMove(dx, dy) {
  // Only allow new move when not already moving
  if (player.moving) return;

  const nx = Math.round(player.x) + dx;
  const ny = Math.round(player.y) + dy;

  // Facing direction
  if (dx > 0) player.facing = 'right';
  else if (dx < 0) player.facing = 'left';
  else if (dy > 0) player.facing = 'down';
  else if (dy < 0) player.facing = 'up';

  if (!isWalkable(nx, ny)) return;

  targetX = nx;
  targetY = ny;
  player.moving = true;
  moveProgress = 0;
}

function getCurrentDir() {
  if (mobileDir) return mobileDir;
  if (keysDown['ArrowUp']    || keysDown['w'] || keysDown['W']) return 'up';
  if (keysDown['ArrowDown']  || keysDown['s'] || keysDown['S']) return 'down';
  if (keysDown['ArrowLeft']  || keysDown['a'] || keysDown['A']) return 'left';
  if (keysDown['ArrowRight'] || keysDown['d'] || keysDown['D']) return 'right';
  return null;
}

const DIRS = { up:[0,-1], down:[0,1], left:[-1,0], right:[1,0] };

// ==================== GAME LOOP ====================
function gameLoop(ts) {
  const dt = Math.min((ts - lastTime) / 1000, 0.1);
  lastTime = ts;

  if (player.moving) {
    moveProgress += dt * moveSpeed;
    if (moveProgress >= 1) {
      moveProgress = 1;
      player.x = targetX;
      player.y = targetY;
      player.moving = false;
    } else {
      const prevX = targetX - (DIRS[player.facing][0]);
      const prevY = targetY - (DIRS[player.facing][1]);
      player.x = prevX + (targetX - prevX) * moveProgress;
      player.y = prevY + (targetY - prevY) * moveProgress;
    }
  }

  if (!player.moving) {
    const dir = getCurrentDir();
    if (dir && DIRS[dir]) {
      tryMove(...DIRS[dir]);
    }
  }

  const isWalking = player.moving;
  if (isWalking !== walking) {
    walking = isWalking;
    if (walking) character.classList.add('walking');
    else character.classList.remove('walking');
  }

  updateCamera();
  requestAnimationFrame(gameLoop);
}

// ==================== KEYBOARD INPUT ====================
window.addEventListener('keydown', e => {
  keysDown[e.key] = true;
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) {
    e.preventDefault();
  }
});
window.addEventListener('keyup', e => { keysDown[e.key] = false; });

// ==================== MOBILE D-PAD ====================
function setupDpad() {
  const btns = {
    'btn-up': 'up',
    'btn-down': 'down',
    'btn-left': 'left',
    'btn-right': 'right'
  };

  for (const [id, dir] of Object.entries(btns)) {
    const btn = document.getElementById(id);

    const pressedSet = new Set();

    const start = (e) => {
      e.preventDefault();
      mobileDir = dir;
      btn.classList.add('pressed');
    };
    const end = (e) => {
      e.preventDefault();
      if (mobileDir === dir) mobileDir = null;
      btn.classList.remove('pressed');
    };

    btn.addEventListener('touchstart', start, { passive: false });
    btn.addEventListener('touchend', end, { passive: false });
    btn.addEventListener('touchcancel', end, { passive: false });
    btn.addEventListener('mousedown', start);
    btn.addEventListener('mouseup', end);
    btn.addEventListener('mouseleave', end);
  }
}

// ==================== LOAD MAP & START ====================
async function loadMap(url) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Failed to load map: ${res.status} ${res.statusText}`);
  const text = await res.text();
  return parseMap(text);
}

async function init() {
  try {
    const grid = await loadMap('/maps/test.json');

    if (grid.length === 0) throw new Error('Map is empty or invalid');

    buildMap(grid);

    // Find a walkable starting position
    let startX = 1, startY = 1;
    outer:
    for (let r = 0; r < grid.length; r++) {
      for (let c = 0; c < grid[r].length; c++) {
        if (getTileDef(grid[r][c]).walkable) {
          startX = c; startY = r; break outer;
        }
      }
    }

    player.x = startX; player.y = startY;
    targetX = startX; targetY = startY;

    setupDpad();
    updateCamera();

    // Hide loading
    document.getElementById('loading').style.display = 'none';

    lastTime = performance.now();
    requestAnimationFrame(gameLoop);

  } catch (err) {
    console.error(err);
    document.getElementById('loading').style.display = 'none';
    const es = document.getElementById('error-screen');
    document.getElementById('error-msg').textContent = err.message;
    es.style.display = 'flex';
  }
}

init();
</script>
</body>
  </html>
      
