<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D RPG Game - Ragnarok Style</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; width: 100vw; height: 100vh; font-family: sans-serif; }
        #game-ui { position: fixed; top: 10px; left: 10px; color: white; pointer-events: none; text-shadow: 1px 1px 2px black; }
        
        /* D-PAD สำหรับมือถือ */
        #dpad {
            position: fixed; bottom: 20px; right: 20px; z-index: 200;
            display: grid; grid-template-columns: repeat(3, 50px); grid-template-rows: repeat(3, 50px); gap: 5px;
        }
        .dbtn {
            background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4);
            border-radius: 10px; color: white; display: flex; align-items: center; justify-content: center;
            font-size: 20px; cursor: pointer; user-select: none; backdrop-filter: blur(5px);
        }
        .dbtn.active { background: rgba(255,255,255,0.5); transform: scale(0.9); }
        .empty { pointer-events: none; opacity: 0; }
        
        @media (min-width: 1024px) { #dpad { display: none; } }
    </style>
</head>
<body>

<div id="game-ui">
    <p>ขวาเมาส์ค้าง: หมุนมุมกล้อง</p>
    <p>WASD / ลูกศร: เดินตามทิศที่มอง</p>
</div>

<div id="dpad">
    <div class="empty"></div><div class="dbtn" id="d-up">▲</div><div class="empty"></div>
    <div class="dbtn" id="d-left">◀</div><div class="empty"></div><div class="dbtn" id="d-right">▶</div>
    <div class="empty"></div><div class="dbtn" id="d-down">▼</div><div class="empty"></div>
</div>

<script>
// --- CONFIGURATION ---
const TILE_SIZE = 1;
const MOVE_SPEED = 5; // tiles per second
const TILE_DEFS = {
    grass1: { walkable: true, img: 'img/map/grass1.png', color: 0x5a9940 },
    grass2: { walkable: true, img: 'img/map/grass2.png', color: 0x4a8835 },
};

// --- THREE.JS SETUP ---
let scene, camera, renderer, clock;
let playerGroup, playerModel;
let mapGroup;
let grid = [];
let isRotating = false;
let cameraAngle = Math.PI / 4; // มุมเริ่มต้น
let cameraPitch = Math.PI / 3; // ก้มมองลงมา
let keys = {};
let mobileDir = null;

function initThree() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // ท้องฟ้า

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10, 20, 10);
    light.castShadow = true;
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));

    mapGroup = new THREE.Group();
    scene.add(mapGroup);

    // สร้างตัวละคร (แทนด้วยกล่องแบบ RPG)
    playerGroup = new THREE.Group();
    const bodyGeo = new THREE.BoxGeometry(0.5, 0.8, 0.3);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2244bb });
    playerModel = new THREE.Mesh(bodyGeo, bodyMat);
    playerModel.position.y = 0.4; // ยกให้เท้าแตะพื้น
    playerModel.castShadow = true;
    playerGroup.add(playerModel);
    scene.add(playerGroup);

    clock = new THREE.Clock();
}

function parseMap(text) {
    return text.trim().split('\n')
        .map(line => [...line.matchAll(/\[([a-zA-Z0-9_]+)\]/g)].map(m => m[1].toLowerCase()))
        .filter(r => r.length);
}

function buildMap(g) {
    grid = g;
    const loader = new THREE.TextureLoader();
    
    g.forEach((row, r) => {
        row.forEach((tileName, c) => {
            const def = TILE_DEFS[tileName] || TILE_DEFS.grass1;
            const geo = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
            const mat = new THREE.MeshStandardMaterial({ 
                color: def.color,
                side: THREE.DoubleSide 
            });

            // ลองโหลดรูป ถ้าโหลดไม่ได้จะใช้สีแทน
            loader.load(def.img, (tex) => {
                tex.magFilter = THREE.NearestFilter;
                mat.map = tex;
                mat.color.set(0xffffff);
                mat.needsUpdate = true;
            }, undefined, () => {});

            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.set(c * TILE_SIZE, 0, r * TILE_SIZE);
            mesh.receiveShadow = true;
            mapGroup.add(mesh);
        });
    });
}

function getWalkable(x, z) {
    const r = Math.round(z);
    const c = Math.round(x);
    if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length) return false;
    const tileName = grid[r][c];
    return (TILE_DEFS[tileName] || {walkable: true}).walkable;
}

// --- INPUT & CAMERA CONTROL ---
function setupControls() {
    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => delete keys[e.key.toLowerCase()]);
    
    window.addEventListener('mousedown', e => { if (e.button === 2) isRotating = true; });
    window.addEventListener('mouseup', e => { if (e.button === 2) isRotating = false; });
    window.addEventListener('contextmenu', e => e.preventDefault());

    window.addEventListener('mousemove', e => {
        if (isRotating) {
            cameraAngle -= e.movementX * 0.005;
            cameraPitch = Math.max(0.2, Math.min(Math.PI / 2.1, cameraPitch + e.movementY * 0.005));
        }
    });

    // Mobile D-pad
    const dirs = ['up', 'down', 'left', 'right'];
    dirs.forEach(d => {
        const btn = document.getElementById('d-' + d);
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileDir = d; btn.classList.add('active'); });
        btn.addEventListener('touchend', () => { mobileDir = null; btn.classList.remove('active'); });
    });
}

function update() {
    const dt = clock.getDelta();
    let moveX = 0;
    let moveZ = 0;

    const inputDir = mobileDir || (keys['w'] || keys['arrowup'] ? 'up' : keys['s'] || keys['arrowdown'] ? 'down' : keys['a'] || keys['arrowleft'] ? 'left' : keys['d'] || keys['arrowright'] ? 'right' : null);

    if (inputDir) {
        // คำนวณทิศทางเดินตามมุมกล้อง (Forward คือทิศที่กล้องมองไป)
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngle));
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngle));

        if (inputDir === 'up') { moveX = forward.x; moveZ = forward.z; }
        if (inputDir === 'down') { moveX = -forward.x; moveZ = -forward.z; }
        if (inputDir === 'left') { moveX = -right.x; moveZ = -right.z; }
        if (inputDir === 'right') { moveX = right.x; moveZ = right.z; }

        const nextX = playerGroup.position.x + moveX * MOVE_SPEED * dt;
        const nextZ = playerGroup.position.z + moveZ * MOVE_SPEED * dt;

        if (getWalkable(nextX, nextZ)) {
            playerGroup.position.x = nextX;
            playerGroup.position.z = nextZ;
            
            // หมุนโมเดลตัวละครไปตามทิศที่เดิน
            const targetAngle = Math.atan2(moveX, moveZ);
            playerModel.rotation.y = targetAngle;
        }
    }

    // อัปเดตตำแหน่งกล้องให้ตามตัวละคร
    const camDist = 8;
    camera.position.x = playerGroup.position.x + Math.sin(cameraAngle) * camDist * Math.cos(cameraPitch);
    camera.position.z = playerGroup.position.z + Math.cos(cameraAngle) * camDist * Math.cos(cameraPitch);
    camera.position.y = playerGroup.position.y + Math.sin(cameraPitch) * camDist;
    camera.lookAt(playerGroup.position);
}

function animate() {
    update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

// --- START GAME ---
async function start() {
    initThree();
    setupControls();

    const fallbackMap = `
[grass2][grass1][grass1][grass2][grass1][path][path][grass1][grass2][grass1]
[grass1][grass1][grass1][grass1][grass1][path][grass2][grass1][grass1][grass1]
[grass1][tree][grass1][grass2][grass1][path][grass1][grass1][tree][grass1]
[grass2][grass1][grass1][grass1][path][path][grass1][grass2][grass1][grass1]
[grass1][grass1][tree][grass1][path][grass1][grass1][grass1][grass1][grass2]
[grass1][grass2][grass1][grass1][path][grass1][grass2][tree][grass1][grass1]
[grass1][grass1][grass1][grass2][path][path][path][grass1][grass1][grass1]
[grass2][tree][grass1][grass1][grass1][grass2][path][grass1][grass2][grass1]
[grass1][grass1][grass1][grass1][grass2][grass1][path][path][grass1][grass1]
[grass1][grass1][grass2][grass1][grass1][grass1][grass1][path][grass1][grass2]
    `.trim();

    buildMap(parseMap(fallbackMap));
    
    // ตั้งจุดเริ่มต้น
    playerGroup.position.set(5, 0, 5);
    
    animate();
}

window.onload = start;
window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>
