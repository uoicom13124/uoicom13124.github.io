<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>2.5D Rotating Map Game - Enhanced</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; width: 100vw; height: 100vh; font-family: sans-serif; }
        canvas { display: block; }

        /* UI Overlay */
        #ui-layer {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            z-index: 100;
        }

        #camera-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .btn-ui {
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: 1px solid #fff;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            pointer-events: auto;
        }
        .btn-ui:active { background: #444; }
        .btn-active { background: #2d5a27; border-color: #5f5; }

        /* Mobile D-Pad */
        #dpad {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 200;
            display: none;
            touch-action: none;
        }
        .dpad-grid { display: grid; grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(3, 60px); gap: 5px; }
        .dbtn {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 10px;
            color: white;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; pointer-events: auto; cursor: pointer;
            user-select: none; -webkit-tap-highlight-color: transparent;
        }
        .dbtn.active { background: rgba(255,255,255,0.5); transform: scale(0.9); }
        .dbtn-empty { pointer-events: none; }
        @media (pointer: coarse), (max-width: 768px) { #dpad { display: block; } }
    </style>
</head>
<body>

<div id="ui-layer">
    <p>เดิน: WASD หรือ D-Pad</p>
    <p id="rot-hint">มุมมองหมุน: คลิกค้างเพื่อลากหมุน</p>
</div>

<div id="camera-controls">
    <button id="cam-normal" class="btn-ui btn-active">มุมมองปกติ</button>
    <button id="cam-rotate" class="btn-ui">มุมมองหมุนได้</button>
</div>

<div id="dpad">
    <div class="dpad-grid">
        <div class="dbtn-empty"></div>
        <div id="d-up" class="dbtn">▲</div>
        <div class="dbtn-empty"></div>
        <div id="d-left" class="dbtn">◀</div>
        <div class="dbtn-empty"></div>
        <div id="d-right" class="dbtn">▶</div>
        <div class="dbtn-empty"></div>
        <div id="d-down" class="dbtn">▼</div>
        <div class="dbtn-empty"></div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/** * CONFIGURATION
 */
const TILE_SIZE = 1; 
const MOVE_SPEED = 5;
const TILE_DEFS = {
    grass1: { walkable: true, img: 'img/map/grass1.png', color: 0x5a9940 },
    grass2: { walkable: true, img: 'img/map/grass2.png', color: 0x4a8835, hasParticle: true },
};

let scene, camera, renderer, clock;
let mapGroup, playerMesh;
let grid = [], mapRows = 0, mapCols = 0;
let keys = {};
let mobileDir = null;

// Player & Camera State
let playerPos = new THREE.Vector3(0, 0, 0);
let targetPos = new THREE.Vector3(0, 0, 0);
let isMoving = false;

let cameraAngle = 0; 
let cameraPitch = Math.PI / 4.5; // ประมาณ 40 องศา
let isDragging = false;
let previousMouse = { x: 0, y: 0 };
let cameraMode = 'normal'; // 'normal' or 'rotate'

const billboards = []; // เก็บอ้างอิงของ particle เพื่อหมุนตามกล้อง

/** * INITIALIZATION
 */
async function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // Sky blue
    clock = new THREE.Clock();

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambientLight);

    // Load Map
    let mapText = `[grass2][grass1][grass1][grass2][grass1][path][path][grass1][grass2][grass1]
[grass1][grass1][grass1][grass1][grass1][path][grass2][grass1][grass1][grass1]
[grass1][tree][grass1][grass2][grass1][path][grass1][grass1][tree][grass1]
[grass2][grass1][grass1][grass1][path][path][grass1][grass2][grass1][grass1]
[grass1][grass1][tree][grass1][path][grass1][grass1][grass1][grass1][grass2]`;

    grid = parseMap(mapText);
    mapRows = grid.length;
    mapCols = grid[0].length;

    mapGroup = new THREE.Group();
    const loader = new THREE.TextureLoader();
    
    // Particle Texture
    const grassParticleTex = loader.load('img/map/grass2_1.png', undefined, undefined, () => {
        console.warn("Please ensure img/map/grass2_1.png exists.");
    });
    grassParticleTex.magFilter = THREE.NearestFilter;

    for (let r = 0; r < mapRows; r++) {
        for (let c = 0; c < mapCols; c++) {
            const tileKey = grid[r][c];
            const def = TILE_DEFS[tileKey] || TILE_DEFS.grass1;
            
            // Floor Plane
            const geometry = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
            const material = new THREE.MeshBasicMaterial({ color: def.color });
            const tile = new THREE.Mesh(geometry, material);
            tile.rotation.x = -Math.PI / 2;
            tile.position.set(c * TILE_SIZE, 0, r * TILE_SIZE);
            mapGroup.add(tile);

            // Add Grass Particle if grass2
            if (def.hasParticle) {
                const pMat = new THREE.SpriteMaterial({ map: grassParticleTex, transparent: true });
                const sprite = new THREE.Sprite(pMat);
                sprite.scale.set(0.6, 0.6, 1);
                sprite.position.set(c * TILE_SIZE, 0.3, r * TILE_SIZE); // ลอยสูงจากพื้นเล็กน้อย
                scene.add(sprite);
                billboards.push(sprite); // เก็บไว้ในลิสต์เพื่อให้ Sprite หันตามกล้องอัตโนมัติ (Default behavior of Sprite)
            }
        }
    }
    scene.add(mapGroup);

    // Player
    const pGeo = new THREE.BoxGeometry(0.4, 0.6, 0.4);
    const pMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
    playerMesh = new THREE.Mesh(pGeo, pMat);
    playerMesh.position.y = 0.3; 
    scene.add(playerMesh);

    // Start Position
    playerPos.set(5, 0, 2);
    targetPos.copy(playerPos);

    setupControls();
    animate();
}

function parseMap(text) {
    return text.trim().split('\n').map(line => [...line.matchAll(/\[([a-zA-Z0-9_]+)\]/g)].map(m => m[1].toLowerCase())).filter(r => r.length);
}

function setupControls() {
    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => delete keys[e.key.toLowerCase()]);

    // UI Buttons
    document.getElementById('cam-normal').onclick = () => {
        cameraMode = 'normal';
        cameraAngle = 0;
        document.getElementById('cam-normal').classList.add('btn-active');
        document.getElementById('cam-rotate').classList.remove('btn-active');
        document.getElementById('rot-hint').style.display = 'none';
    };
    document.getElementById('cam-rotate').onclick = () => {
        cameraMode = 'rotate';
        document.getElementById('cam-rotate').classList.add('btn-active');
        document.getElementById('cam-normal').classList.remove('btn-active');
        document.getElementById('rot-hint').style.display = 'block';
    };

    // Interaction for Rotation
    const onDown = (x, y) => { if(cameraMode === 'rotate') { isDragging = true; previousMouse = { x, y }; } };
    const onMove = (x, y) => {
        if (!isDragging) return;
        const deltaX = x - previousMouse.x;
        cameraAngle -= deltaX * 0.01;
        previousMouse = { x, y };
    };

    renderer.domElement.addEventListener('mousedown', e => onDown(e.clientX, e.clientY));
    window.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', () => isDragging = false);

    renderer.domElement.addEventListener('touchstart', e => onDown(e.touches[0].clientX, e.touches[0].clientY));
    window.addEventListener('touchmove', e => onMove(e.touches[0].clientX, e.touches[0].clientY));
    window.addEventListener('touchend', () => isDragging = false);

    // D-Pad
    const btnMap = { up:'d-up', down:'d-down', left:'d-left', right:'d-right' };
    for (const [dir, id] of Object.entries(btnMap)) {
        const btn = document.getElementById(id);
        const press = e => { e.preventDefault(); mobileDir = dir; btn.classList.add('active'); };
        const release = e => { e.preventDefault(); if (mobileDir === dir) mobileDir = null; btn.classList.remove('active'); };
        btn.addEventListener('touchstart', press); btn.addEventListener('mousedown', press);
        btn.addEventListener('touchend', release); btn.addEventListener('mouseup', release);
    }
}

function getMoveDir() {
    if (mobileDir) return mobileDir;
    if (keys['w'] || keys['arrowup']) return 'up';
    if (keys['s'] || keys['arrowdown']) return 'down';
    if (keys['a'] || keys['arrowleft']) return 'left';
    if (keys['d'] || keys['arrowright']) return 'right';
    return null;
}

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    // 1. Movement Logic
    if (!isMoving) {
        const input = getMoveDir();
        if (input) {
            let moveAngle = 0;
            if (input === 'up') moveAngle = 0;
            if (input === 'down') moveAngle = Math.PI;
            if (input === 'left') moveAngle = Math.PI / 2;
            if (input === 'right') moveAngle = -Math.PI / 2;

            const combinedAngle = cameraAngle + moveAngle;
            const dx = -Math.round(Math.sin(combinedAngle));
            const dz = -Math.round(Math.cos(combinedAngle));

            const nx = playerPos.x + dx;
            const nz = playerPos.z + dz;

            // Simple boundary check
            if (nx >= 0 && nx < mapCols && nz >= 0 && nz < mapRows) {
                const tileType = grid[nz][nx];
                if ((TILE_DEFS[tileType] || TILE_DEFS.grass1).walkable) {
                    targetPos.set(nx, 0, nz);
                    isMoving = true;
                }
            }
        }
    } else {
        playerPos.lerp(targetPos, dt * MOVE_SPEED * 2);
        if (playerPos.distanceTo(targetPos) < 0.05) {
            playerPos.copy(targetPos);
            isMoving = false;
        }
    }

    // Update Player Mesh
    playerMesh.position.x = playerPos.x;
    playerMesh.position.z = playerPos.z;
    playerMesh.rotation.y = cameraAngle;

    // 2. Camera Update
    const camDist = 7;
    const targetCamX = playerMesh.position.x + Math.sin(cameraAngle) * camDist * Math.cos(cameraPitch);
    const targetCamZ = playerMesh.position.z + Math.cos(cameraAngle) * camDist * Math.cos(cameraPitch);
    const targetCamY = camDist * Math.sin(cameraPitch);

    camera.position.set(targetCamX, targetCamY, targetCamZ);
    camera.lookAt(playerMesh.position);

    renderer.render(scene, camera);
}

window.onload = init;
window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>

