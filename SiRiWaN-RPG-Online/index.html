<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Siriwan RPG 3D - RO Style</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --ui-blue: #00d2ff;
        }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Tahoma', sans-serif; }
        
        /* Loading Overlay */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #0d0d1a; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 3000;
            transition: opacity 0.5s;
        }
        .progress-bar { width: 200px; height: 10px; background: #222; border-radius: 5px; margin-top: 10px; overflow: hidden; }
        #progress-fill { width: 0%; height: 100%; background: var(--ui-blue); transition: width 0.2s; }

        /* Game UI */
        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 100;
        }
        #inventory {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; background: rgba(0,0,0,0.6); padding: 10px;
            border-radius: 10px; border: 1px solid rgba(255,255,255,0.2); pointer-events: auto;
        }
        .slot {
            width: 45px; height: 45px; background: rgba(255,255,255,0.1);
            border: 2px solid #444; border-radius: 5px; cursor: pointer;
        }
        .slot.active { border-color: var(--ui-blue); box-shadow: 0 0 10px var(--ui-blue); }

        canvas { display: block; }
    </style>
</head>
<body>

<div id="loader">
    <h2 style="color: white;">กำลังโหลดแมพและอาเซท...</h2>
    <div class="progress-bar"><div id="progress-fill"></div></div>
</div>

<div id="ui-layer">
    <div id="inventory">
        <div class="slot active" onclick="selectSlot(0)"></div>
        <div class="slot" onclick="selectSlot(1)"></div>
        <div class="slot" onclick="selectSlot(2)"></div>
        <div class="slot" onclick="selectSlot(3)"></div>
        <div class="slot" onclick="selectSlot(4)"></div>
    </div>
</div>

<script>
    // Configuration & State
    const TILE_SIZE = 2; 
    let mapData = [];
    let player = {
        pos: { x: 5, y: 5 },
        target: null,
        mesh: null,
        speed: 0.15
    };

    // Camera Controls State
    let isRightMouseDown = false;
    let cameraRotation = { theta: 0, phi: Math.PI / 4, radius: 25 };
    let mouseLastPos = { x: 0, y: 0 };

    // Three.js Core
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const textureLoader = new THREE.TextureLoader();
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // 1. Asset Loading System (Optimization)
    const loadAssets = async () => {
        const fill = document.getElementById('progress-fill');
        
        // Mocking Map Data Loading from maps/test.json
        // In real environment use: fetch('maps/test.json').then(r => r.json())
        // For this demo, we simulate the JSON structure
        try {
            // จำลองการดึงไฟล์
            const response = await Promise.resolve({
                grid: Array(20).fill().map(() => Array(20).fill().map(() => Math.random() > 0.5 ? 'grass1' : 'grass2'))
            });
            mapData = response.grid;
            fill.style.width = '50%';
            
            initGame();
            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => document.getElementById('loader').remove(), 500);
        } catch (e) {
            console.error("Map load failed", e);
        }
    };

    // 2. Initialize 3D Scene
    function initGame() {
        // Lighting
        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 0.5);
        sun.position.set(10, 20, 10);
        scene.add(sun);

        // Ground Tiles (จาก JSON)
        const planeGeo = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
        
        // เราใช้เทคนิค InstancedMesh หรือสร้าง Merge Geometry จะโหลดเร็วขึ้น 
        // แต่เพื่อความเข้าใจง่ายในที่นี้จะสร้าง Group ครับ
        const mapGroup = new THREE.Group();
        
        mapData.forEach((row, r) => {
            row.forEach((tileType, c) => {
                const color = tileType === 'grass1' ? 0x5a8a4a : 0x4a7a3a;
                const mat = new THREE.MeshStandardMaterial({ 
                    color: color,
                    // side: THREE.DoubleSide
                });
                const tile = new THREE.Mesh(planeGeo, mat);
                tile.rotation.x = -Math.PI / 2;
                tile.position.set(c * TILE_SIZE, 0, r * TILE_SIZE);
                tile.userData = { gridX: c, gridY: r }; // เก็บพิกัดไว้เช็คคลิก
                mapGroup.add(tile);
            });
        });
        scene.add(mapGroup);

        // Player (2.5D Billboard)
        const playerTex = textureLoader.load('https://i.imgur.com/vHq0u66.png'); // รูปตัวอย่าง
        playerTex.magFilter = THREE.NearestFilter;
        const playerMat = new THREE.SpriteMaterial({ map: playerTex });
        player.mesh = new THREE.Sprite(playerMat);
        player.mesh.scale.set(2, 2, 1);
        player.mesh.position.set(player.pos.x * TILE_SIZE, 1.2, player.pos.y * TILE_SIZE);
        scene.add(player.mesh);

        updateCameraPosition();
        animate();
    }

    // 3. Mouse Interaction Logic
    window.addEventListener('mousedown', (e) => {
        if (e.button === 0) { // Left Click - Walk
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                const target = intersects.find(i => i.object.userData.gridX !== undefined);
                if (target) {
                    player.target = { 
                        x: target.object.userData.gridX, 
                        y: target.object.userData.gridY 
                    };
                }
            }
        } else if (e.button === 2) { // Right Click - Rotate Camera
            isRightMouseDown = true;
            mouseLastPos = { x: e.clientX, y: e.clientY };
        }
    });

    window.addEventListener('mouseup', () => {
        isRightMouseDown = false;
    });

    window.addEventListener('mousemove', (e) => {
        if (isRightMouseDown) {
            const dx = e.clientX - mouseLastPos.x;
            const dy = e.clientY - mouseLastPos.y;
            
            cameraRotation.theta -= dx * 0.01;
            cameraRotation.phi = Math.max(0.2, Math.min(Math.PI / 2.1, cameraRotation.phi + dy * 0.01));
            
            mouseLastPos = { x: e.clientX, y: e.clientY };
            updateCameraPosition();
        }
    });

    // Zoom
    window.addEventListener('wheel', (e) => {
        cameraRotation.radius = Math.max(10, Math.min(60, cameraRotation.radius + e.deltaY * 0.05));
        updateCameraPosition();
    });

    // Disable context menu for right click
    window.addEventListener('contextmenu', e => e.preventDefault());

    function updateCameraPosition() {
        camera.position.x = player.mesh.position.x + cameraRotation.radius * Math.sin(cameraRotation.theta) * Math.cos(cameraRotation.phi);
        camera.position.z = player.mesh.position.z + cameraRotation.radius * Math.cos(cameraRotation.theta) * Math.cos(cameraRotation.phi);
        camera.position.y = player.mesh.position.y + cameraRotation.radius * Math.sin(cameraRotation.phi);
        camera.lookAt(player.mesh.position);
    }

    // 4. Game Loop & Movement
    function animate() {
        requestAnimationFrame(animate);

        // Player Auto Movement
        if (player.target) {
            const targetX = player.target.x * TILE_SIZE;
            const targetY = player.target.y * TILE_SIZE;
            
            const dx = targetX - player.mesh.position.x;
            const dz = targetY - player.mesh.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.1) {
                player.mesh.position.x += (dx / dist) * player.speed;
                player.mesh.position.z += (dz / dist) * player.speed;
                updateCameraPosition();
            } else {
                player.target = null;
            }
        }

        renderer.render(scene, camera);
    }

    // Utility
    function selectSlot(i) {
        document.querySelectorAll('.slot').forEach((s, idx) => {
            s.classList.toggle('active', idx === i);
        });
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start
    loadAssets();
</script>
</body>
</html>
